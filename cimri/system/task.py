""" cimri matcher system--------------------   date:                    01.31.2012author:                  gun@alppay.comdescription:------------revision history: -----------------gun@alppay.com:          initial version"""import timeimport jsonimport codecsimport os.pathimport mongoenginefrom mongoengine import *import datetimeimport hashlibimport uuidfrom cimri.system.data import DataObjectfrom cimri.system.document import SerialDocfrom cimri.api.cimriservice.data.merchantitem import MerchantItemfrom cimri.system.config import Configfrom cimri.util.token import *class Task(object):        """	Sistem icindeki modullerin calistirdigi islemleri tanimlar.	Taskler birden fazla bolum olarak filesystema yazilir. Tasklerin filsystemdaki yeri sistem konfigurasyonu dosyasinda belirlenir.		Tasklerin ayri ayri yuklenebilecek olan bolumleri su sekildedir:	info - genel task bilgileri	data - Taskin uzerinde calistigi veriler	result - Task sonuclari	log - Task loglari	error - islem sirasinda Taskin karsilastigi hatalar	feedback - islem sirasinda Taskin diger islemlere yardimci olabilmek icin bulup kayit ettigi ekstra bilgiler.        """	STATUS_NEW="new"			#when task is created	STATUS_PENDING="pending"		#when task is waiting on dependencies to be scheduled	STATUS_SCHEDULED="scheduled"		#task is scheduled. ready to be dispatched	STATUS_DISPATCHED="dispatched"		#task dispatched to module	STATUS_STARTED="started"			STATUS_SUSPENDED="suspended"	STATUS_CANCELLED="cancelled"	STATUS_ERROR="error"	STATUS_COMPLETE="complete"	#the task is saved in multiple files. each section below declares the fields that it contains	sections={"info":	["id","threadid","threadtags","created","duration","target","status","progress","op","meta","stats"],		  "data":	["data"],		  "result":	["result"],	 	  "log":	["log"],		  "error":	["error"],		  "feedback":	["feedback"]		  }	def __init__(self):		#unique task id		self.id=generate_uuid()		#thread id (in order to correlate related tasks)		self.threadid=""		#thread tags		self.threadtags=""		#time task is created		self.created=time.time()		#total running duration of task		self.duration=0		#target module		self.target=None		#task status		self.status=Task.STATUS_NEW		#task progres		self.progress=0		#operation to perform		self.op=None		#any extra information to pass to module for processing the task		self.meta={}						#stats 		self.stats={"data"  :  {"processed"	:0,	#number of data items processed without errors			    		"total"    	:0},	#total number of items to be processed			    "errors": 	0,			#number of error generated			    "test"  :  {"passed"    	:0,	#number of results that match the expected ref. data					"failed"	:0,	#number of results that did not match the ref. data					"accuracy"	:0},	#a measure of accuracy (%)								#other test values can be tracked by indivudal modules			    "times" :  {}			#breakdown of durations for each suboperation			   }		#data to operate on		#each element on the list will be a dictionary with the following keys:		#	"data"		: the actual module-specific data unit to operate on		#	"meta.*"	: any meta information to supplement the data unit		#			  can be passed with keys starting with meta.		#		   	  ie: meta.merchants.index, meta.merchants.items.index,...		self.data=[]							#result data and status.		#each element that is retured within the list will have the exact same format		#as the data field as described above		self.result=[]		#extra info discovered/gathered during task		self.feedback=[]		#log		self.log=[]		#errors		self.error=[]			def save(self):	        """		Taski filesystema yazarak kaydeder.	        """		#save in sections		sections=Task.sections.keys()		#get path		path=Config.getconfig("SYS").get("task_store_path")		#save each section		for section in sections:			f=codecs.open(os.path.join(path,self._file_name(section)),"w","utf-8")			f.write(self.pack(section))	       		f.close()		def load(self,section=None):	        """		Taskin butununu ya da sadece bir bolumunu filesystemdaki kayitli kopyasindan yukler.		        @type  section: str	        @param section: Task'in yuklenmesi istenen bolumu. eger None ise butun task bolumleri yuklenir.	        """		#sections to load		sections=Task.sections.keys()		if section is not None:			sections=[section]				#get patch		path=Config.getconfig("SYS").get("task_store_path")		#read 		for section in sections:			try:				f=codecs.open(os.path.join(path,self._file_name(section)),"r","utf-8")				text=f.read()	       			f.close()				#unpack				self.unpack(text)			except Exception as e:				#this is mainly to handle log files created before 12.31.11 (they did not				#have a separate -error- file 				pass	def unload(self):	        """		Taskin yuklenmis bilgilerini object icindeki kopyadan kaldirir. Buradaki amac memory management amaci olarak gerekli		olmayan hafizayi sisteme geri vermektir.	        """		#free memory for all sections except for the 		self.data=[]			self.result=[]		self.feedback=[]		self.log=[]		self.error=[]	@classmethod	def create_from_file(self,file):	        """		Bir dosyaya dayali olarak yeni bir Task objecti yaratir		        @type  file: str	        @param file: Task bilgilerini iceren dosyanin path ve ismi	        @rtype: L{cimri.system.task.Task}	        @return: yaratilan Task objecti	        """		#create		task=Task()		#read		f=codecs.open(file,"r","utf-8")		text=f.read()	        f.close()		#unpack		task.unpack(text)				return task	def pack(self,section=None):	        """		Bir Task objectinin belirli bir bolumunu ya da tumunu json olarak encode eder.		        @type  section: str	        @param section: Task'in json olarak encode edilmesi istenen bolumu. eger None ise butun task bolumleri encode edilir.	        @rtype: str	        @return: json olarak encode edilen Task bolumlerini iceren json paketi	        """		#sections to pack		sections=Task.sections.keys()		if section is not None:			sections=[section]		#pack		data={}		for section in sections:			for attr in Task.sections[section]:					data[attr]=self._pack(getattr(self,attr))			return json.dumps(data)	def unpack(self,text):	        """		Belirli bir json stringden Task bilgilerini yukler.	        @type  text: str	        @param text: Task bilgilerini iceren json paketi	        """		#parse		data=json.loads(text)		#unpack			for attr in data:			setattr(self,attr,self._unpack(data[attr]))		def _pack(self,data):	        """		Bellirli bir veriyi json olarak encode edilebilecek bir formata gecirir. Verilen veriyi recursive olarak tarayarak		list, dict, ya da object turunde olan verileri formatlar. 		        @type  data: list, dict, object	        @param data: formatlanmasi istenen veri	        @rtype: list, dict	        @return: json olarak encode edilebilecek bir sekilde formatlanmis veri	        """		if data.__class__.__name__=='list':			return [self._pack(val) for val in data]		elif data.__class__.__name__=='dict':			return dict((key,self._pack(data[key])) for key in data)					elif issubclass(data.__class__,DataObject):			return {"__class__":data.__class__.__name__, "dump":data.to_dict()}		else:			return data	def _unpack(self,data):	        """		JSONdan decode edilmis herhangi bir veriyi orjinal formatina cevirir. Verilen veriyi recursive olarak tarayarak		bulunan list, dict, ve object turundeki verileri gercek formatlarina cevirir.        		        @type  data: list, dict	        @param data: formatlanmasi istenen veri	        @rtype: list, dict, object	        @return: saglanan verinin orjinal formatindaki hali	        """		if data.__class__.__name__ == "dict" and "__class__" in data:			cls=globals()[data["__class__"]]			return cls(data["dump"])		elif data.__class__.__name__ == "dict":			for i in data:				data[i]=self._unpack(data[i])			return data					elif data.__class__.__name__ == "list":			for i in range(len(data)):				data[i]=self._unpack(data[i])			return data			else:			return data		def _file_name(self,section=None):	        """		Belirli bir Task bolumu ya da butun Task icin kayit edilebilir orjinal bir dosya ismi yaratir.		        @type  section: str	        @param section: Task'in kayit edilmesi istenen bolumu. eger None ise butun task bolumleri icin bir dosya isimi yaratilir	        @rtype: str	        @return: istenen dosya ismi	        """		tokens=[]		tokens.append(self.threadid[-4:])		tokens.append(self.id)		if section is not None:			tokens.append(section)		tokens.append(self.op)		return "-".join(tokens)