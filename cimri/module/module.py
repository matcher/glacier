""" cimri matcher system--------------------   date:                    01.31.2012author:                  gun@alppay.comdescription:------------revision history: -----------------gun@alppay.com:          initial version"""import osimport os.pathimport sysif __name__=="__main__":	path=os.getcwd()        if path not in sys.path:                sys.path.append(path)import argparsefrom string import Templatefrom twisted.internet import reactor, deferfrom twisted.internet.address import IPv4Addressfrom twisted.web import server, resource, xmlrpcfrom twisted.web.xmlrpc import Proxyfrom cimri.system.fsm import FSMfrom cimri.system.task import Taskfrom cimri.system.logger import Loggerfrom cimri.system.config import Configfrom cimri.util.timeutils import *from cimri.util.token import *import timeclass Module(object,xmlrpc.XMLRPC):        """	Sistem icin tanimli butun modullerin icin base class tanimidir.        """        STATE_RUNNING="running"        STATE_STOPPED="stopped"        STATE_STARTING="starting"        STATE_STOPPING="stopping"        STATE_SHUTTING_DOWN="shuttingdown"	def __init__(self):		#initiate state		self.state= FSM(Module.STATE_RUNNING,				[(Module.STATE_STOPPED,		Module.STATE_STARTING),				 (Module.STATE_STOPPED,		Module.STATE_SHUTTING_DOWN),				 (Module.STATE_STARTING,	Module.STATE_RUNNING),				 (Module.STATE_STARTING,	Module.STATE_STOPPED),				 (Module.STATE_RUNNING,		Module.STATE_STOPPING),				 (Module.STATE_RUNNING,		Module.STATE_SHUTTING_DOWN),				 (Module.STATE_STOPPING,	Module.STATE_STOPPED)				])		#create logger for module		self.logger=Logger.getlogger(self.__class__.__name__)			#instance id		self.id=generate_uuid()				#xmlrpc server setup		self.host=None		self.port=None		self.server=None		self.allowNone = True        	self.useDateTime = True		#queue that has the scheduled tasks		self.queue=[]					#current task that is being processed		self.task=None		self.starttime=None		#progres monitor		self.step=0		self.steps=0		#supported operations (these should be a dictionary of operation name to functions		self.ops={}		#benchmarking		self.stopwatch=0		self.benchmark={}		#list of monitor routines that are called periodically. extending modules should append		#to this list all module specific periodic routines. format is (method, period-in-seconds)		self.monitors=[(self._task_monitor,1)]		#-xmlrpc interface---------------------------------------------------------------------------------		def xmlrpc_ping(self):	                """		XML-RPC ile module "ping" komutu iletir. Modul processin calisiyor durumda olup olmadigini kontrol etmek icin kullanilabilir.                @rtype: str                @return: XML-RPC uzerinden "ok" cevabi yollar.		                """		return "ok"	def xmlrpc_stop(self):                """		XML-RPC ile module "stop" komutu iletir. Stop komutu modulu operasyonel olarak durdurmak icin kullanilir.                @rtype: bool                @return: XML-RPC uzerinden operasyonun sonucunu boolean olarak iletir.	                """        	return(self.stop())	def xmlrpc_start(self):                """		XML-RPC ile module "start" komutu iletir. Start komutu modulu operasyonel olarak calisir statuye gecirmek icin kullanilir.                @rtype: bool                @return: XML-RPC uzerinden operasyonun sonucunu boolean olarak iletir.	                """        	return(self.start())	def xmlrpc_shutdown(self):                """		XML-RPC ile module "shutdown" komutu iletir. Shutdown komutu modulun XML-RPC komutlarini dinlemeyi birakmasi icin kullanilir.                @rtype: bool                @return: XML-RPC uzerinden operasyonun sonucunu boolean olarak iletir.	                """		reactor.callLater(1,self.shutdown)        	return True	def xmlrpc_schedule(self,tasks):                """		XML-RPC ile module "schedule" komutu iletir. Schedule komutu bir task listesini module islemden gecirilmesi icin iletir.                @type  tasks: list L{cimri.system.task.Task}                @param tasks: Task listesi                @rtype: bool                @return: islemden gecirilmek uzere islem listesine eklenen tasklerin idlerinin listesi                """		#unpack tasks		list=[]		try:			for data in tasks:				#unpack				task=Task()				task.unpack(data)				#load fully				task.load()				list.append(task)		except Exception as e:			pass        	return self.schedule(list)	def xmlrpc_flush(self):                """		XML-RPC ile module "flush" komutu iletir. Flush komutu modulun en son tamamladigi Taski birakarak yeni bi Task		kabul edebilecek sekilde beklemeye gecmesini saglar.                @rtype: bool                @return: XML-RPC uzerinden operasyonun sonucunu boolean olarak iletir.	                """		#if task is complated, delete it		if self.task is not None and self.task.status in [Task.STATUS_COMPLETE, Task.STATUS_ERROR]:			self.task=None			#print "DONE "+self.__class__.__name__		return True	def xmlrpc_gettask(self):                """		XML-RPC ile modulde aktif olan Task'i alir. Task'in sadece "info" bolumu iletilir.                @rtype: L{cimri.system.task.Task}                @return: XML-RPC uzerinden modulde aktif olan Task'i yollar	                """		return self.task.pack("info")	def xmlrpc_getstatus(self):                """		XML-RPC ile modulun ve modulde aktif olan Task'in statusu ile ilgili bilgiler alir.                @rtype: dict                @return: modulun statusunu ve aktif olarak uzerinde calistigi Task'in statusunu iceren bir dictionary                 """        	return self.getstatus()	#---------------------------------------------------------------------------------xmlrpc interface-	#-module interface---------------------------------------------------------------------------------		def stop(self):                """		Modulu operasyonel olarak durdurmak icin kullanilir.                @rtype: bool                @return: operasyonun sonucu	                """		#change state		res=self.state.set(Module.STATE_STOPPING)		if res is False:			return res		self.logger.info("module stopping...")				#change state		res=self.state.set(Module.STATE_STOPPED)		if res is False:			return res		self.logger.info("module stopped...")				return res	def start(self):                """		Modulu operasyonel olarak calisir statuye gecirmek icin kullanilir.                @rtype: bool                @return: operasyonun sonucu	                """		#change state		res=self.state.set(Module.STATE_STARTING)		if res is False:			return res		self.logger.info("module starting...")				#change state		res=self.state.set(Module.STATE_RUNNING)		if res is False:			return res		self.logger.info("module running...")				return res	def shutdown(self):                """		Modulun XML-RPC komutlarini dinlemeyi birakmasi icin kullanilir.                @rtype: bool                @return: operasyonun sonucu                """		res=self.state.set(Module.STATE_SHUTTING_DOWN)		if res is False:			return res		self.logger.info("module shutting down...")					#wait for the module to finish all tasks and/or cancel all active/pending tasks		#stop server		try:				if self.server is not None:				self.server.stopListening()		except Exception as e:			pass		#stop		reactor.stop()			def schedule(self,tasks):                """		Bir task listesini module islemden gecirilmesi icin iletir.                @type  tasks: list L{cimri.system.task.Task}                @param tasks: Task listesi                @rtype: list                @return: islemden gecirilmek uzere islem listesine eklenen tasklerin idlerinin listesi                """		#queue tasks		for task in tasks:			self.queue.append(task)		return [task.id for task in tasks]	def getstatus(self):		"""		Modulun ve modulde aktif olan Task'in statusu ile ilgili bilgiler alir.                @rtype: dict                @return: modulun statusunu ve aktif olarak uzerinde calistigi Task'in statusunu iceren bir dictionary 		"""		#get tasks		tasks=[]		if self.task is not None:			tasks.append({"id":self.task.id,				      "threadid":self.task.threadid,				      "threadtags":self.task.threadtags,				      "status":self.task.status,				      "progress":self.task.progress})		for task in self.queue:			tasks.append({"id":task.id,				      "threadid":task.threadid,				      "threadtags":self.task.threadtags,				      "status":task.status,				      "progress":0})				return {"id":self.id,			"module":self.__class__.__name__,			"host":self.host,			"port":self.port,			"status":self.state.get(),			"tasks":tasks}	#---------------------------------------------------------------------------------module interface-	#-module internals---------------------------------------------------------------------------------		def _run(self,host,port):                """		Modulu calisir duruma getirir.                @type host: str                @param host: modulun XML-RPC requestleri dinliecegi ip ya da host name                @type port: int                @param port: modulun XML-RPC requestleri dinliecegi port numarasi		"""		#keep track of ip/port 		self.host=host		self.port=port		#get add		addr=IPv4Address("TCP", host, port)		#run server for incoming xmlrpc calls        	root = resource.Resource()        	root.putChild('', self)	        root.putChild('RPC2', self)		self.server = reactor.listenTCP(addr.port, server.Site(root), interface=addr.host)		#start monitors		for monitor in self.monitors:			self._monitor(monitor,schedule=True)		self.logger.info("module started...")				#start		reactor.run()	def _runtask(self):                """		Modulde islemden gecirilmeyi bekleyen siradaki Taski isleme alir.                """		try:			self.ops[self.task.op]()           	except Exception as e:                  	self._log_exception(e)                  	self._fail()					def _fail(self):                """		Modul icinde islemdeki bir Task isleme devam edilmesini engelleyen bir hata ile karsilastigi takdirde islemi durdurup		Task'i hatali sonuclanmis sekilde kayit etmek icin kullanilir.                """		try:					#update time			self.task.duration=self.task.duration+(time.time()-self.starttime)				#complet			self.task.stats["data"]["processed"]=len(self.task.result)			self.task.status=Task.STATUS_ERROR			self._save()				except Exception as e:			self._log_exception(e,abort=True)			self._save()	def _complete(self):                """		Modul icinde islemdeki bir Task basari ile tamamlandigi zaman Taski tamamlanmis olarak kayit etmek icin kullanilir.                """		try:					#update time			self.task.duration=self.task.duration+(time.time()-self.starttime)				#complete			self.task.stats["data"]["processed"]=len(self.task.result)			self.task.status=Task.STATUS_COMPLETE			self._save()				except Exception as e:			self._log_exception(e,abort=True)			self._save()	def _progress(self,steps=None,stepby=1):                """		Modul icindeki aktif olarak islemde olan Task'in islem stasunu guncellemek icin kullanilir.                @type  steps: int                @param steps: eger None degil ise, islemin kac adim olarak takip edilmesi gerektigini belirler. eger None ise			      islemin statusunu bir adim ilerletir.                @type  stepby: int                @param stepby: islemin statusu bir adim ileri alindigi her zaman aslinda kac adim ileri alinmasi gerektigini belirler.                """		if self.task is None:			return		if steps is not None:			self.steps=steps			self.step=0		else:			self.step=self.step+stepby		if self.steps==0:			self.task.progress=100		else:			self.task.progress=int(100*self.step/self.steps)	def _task_monitor(self):                """		Cagrildigi zaman modul icinde aktif olan Task'in statusunu kontrol eder.                """		#monitor the queue		if len(self.queue)>0 and self.task is None:			#get scheduled task			self.task=self.queue[0]			#dequeue task			self.queue.remove(self.task)			#check that operation is supported			if self.task.op not in self.ops:				self.task=None				return			#get time			self.starttime=time.time()			self.task.progress=0			#process			self.task.status=Task.STATUS_STARTED			self.task.stats["data"]["total"]=len(self.task.data)			self._save()			#start task			reactor.callLater(0,self._runtask)		def _monitor(self,monitor,schedule=False):                """		Modulun statusunu periodik olarak kontrol eden bir monitor baslatir.                @type  monitor: tuple                @param monitor: tuplein ilk elemani monitor icin cagrilmasi gereken fonksiyon, ikinci elemani ise bu fonksiyonun kac saniyede			        bir cagrilacagidir.                @type schedule: bool                @param schedule: eger False ise monitor fonksiyonu ilk kez hemen beklemeden cagrilir, True ise ilk kez belirlenen peridik 				 sureden sonra cagrilir.                """		#if shutting down, stop the monitor		if self.state.get()==Module.STATE_SHUTTING_DOWN:			return		#run monitor		if schedule==False:			monitor[0]()		#schedule 		reactor.callLater(monitor[1],self._monitor,monitor)	def _save(self):                """		Module icinde aktif olan Task'i filesystema kayit ederek gunceller.                """		#save task		self.task.save()	def _parse_argv(self):                """		Modul processi yaratildigi zaman processi yaratan komut ile beraber verilen parametreleri alir.                @rtype: dict                @return: "host" ve "port" bilgilerini iceren bir dictionary                """		#handle runtime arguments		parser=argparse.ArgumentParser()		parser.add_argument('--host',				    nargs='?',				    default=None,				    dest='host',			    	    help='host/ip to run the module on')		parser.add_argument('--port',				    nargs='?',				    default=None,				    dest='port',			    	    help='port to run the module on')		#compile arguments		args=parser.parse_args()		#set parameters		return {"host":args.host,		        "port":int(args.port)}	#---------------------------------------------------------------------------------module internals-	#-utility methods----------------------------------------------------------------------------------	@classmethod	def _callremote(cls,host,port,func,*args):                """		XML-RPC cagrisi yapar.                @type  host: str                @param host: XML-RPC cagrisinin yapilacagi ip adresi ya da host                @type  port: int                @param port: XML-RPC cagrisinin yapilacagi port                @type  func: str                @param func: XML-RPC ile cagrilmak istenen fonksiyonun ismi                @type  args: list                @param args: XML-RPC ile cagrilman fonksiyonun argumanlari                @return: XML-RPC cagrisinin cevabi                """		if host=="localhost":			host="127.0.0.1"					proxy = Proxy("http://"+host+":"+str(port))		return proxy.callRemote(func, *args)	#----------------------------------------------------------------------------------utility methods-	#-logging------------------------------------------------------------------------------------------		def _log_task_msg(self,msg):                """		Task loguna yeni bir mesaj ekler                @type  msg: str                @param msg: loga eklenecek mesaj                """		#add log to task		self.task.log.append(msg)	def _log_error(self,err):                """		Task loguna yeni bir hata mesaji ekler                @type  err: str                @param err: loga eklenecek hata mesaji                """		#add to task errors		self.task.error.append(err)		self.task.stats["errors"]=self.task.stats["errors"]+1	def _log_exception(self,e,data=None,abort=False):                """		Task loguna yeni bir exception mesaji ekler                @type  e: Exception                @param e: loga eklenecek exception                @param data: exception ile beraber loga eklenecek ekstra veriler                @type  abort: bool                @param abort: eger True ise bu exception Task'in basarili ile tamamlanmasina engel olacak bir expcetiondir.                """		abortmsg='' if abort==False else " aborting task..."		datamsg='' if data==None else " data: "+str(data)		timestr=format_time_for_log(time.time())		#log		self.logger.error(Template("task $id encountered an exception${abortmsg}:").substitute(id=self.task.id,abortmsg=abortmsg))			self.logger.error(str(e))				#add log to task		self.task.error.append(Template("exception at $time. see system log for details.${data}${abortmsg}").substitute(time=timestr,data=datamsg,abortmsg=abortmsg))		self.task.stats["errors"]=self.task.stats["errors"]+1	def _log_benchmark(self):                """		Bir Task islemde iken toplanan benchmark istatistiklerini Task loguna yazar.                """		self._log_task_msg("")		self._log_task_msg("benchmark:")		total=reduce(lambda a,b:a+b, (self.benchmark[op] for op in self.benchmark), 0)		for op in self.benchmark:			if total>0:				per=round(100*self.benchmark[op]/total)			else:				per=0			self._log_task_msg(op+": "+str(self.benchmark[op])+" (%"+str(per)+")")	#------------------------------------------------------------------------------------------logging-	#-performance benchmarking-------------------------------------------------------------------------	def _benchmark_start(self,op):                """		Bir islem sirasinda belli bir operasyonun suresini olcmek icin operasyonun baslangic zamanini kayit eder.                @type  op: str                @param op: benchmark edilen operasyonu temsil eden bir id ya da isim                """		self.stopwatch=time.time()		if op not in self.benchmark:			self.benchmark[op]=0	def _benchmark_record(self,op):                """		Bir islem sirasinda belli bir operasyonun suresini olcmek icin operasyonun zamanini kayit eder.                @type  op: str                @param op: benchmark edilen operasyonu temsil eden bir id ya da isim                """		self.benchmark[op]=self.benchmark[op]+time.time()-self.stopwatch	#-------------------------------------------------------------------------performance benchmarking-class Worker():        """	Bir islemin birden fazla asynchronous parca halinde concurrently calistirilmasini saglayan temel isci mekanizmasi.        """	def __init__(self,distributor,id=None):                """                @type  distributor: L{cimri.module.module.Distributor}                @param distributor: bu Worker objectinin calisma contextini tanimlayan Distributor objecti                @type  id: str                @param id: Worker objectini unique olarak tanimlayan opsiyonel bir id                """		#init		self.distributor=distributor		#id		self.id=id		#create worker 		self.worker=self._worker()		#prepare worker coroutine		self.worker.next()	def _worker(self):                """		Worker'a verilen islemleri gerceklestiren coroutine                 """		while True:			#wait for data 			data=yield			#get processor function				func=self.distributor.processor			#process data			func(data,self)	def next(self):                """		Workerin uzerinde calistigi islemi tamamladigi zaman Distributorden bir sonraki islemi beklemek icin cagrilir.                """		#let dispatcher know, worker is ready for next task		reactor.callLater(0,self._next)	def _next(self):                """		Workerin uzerinde calistigi islemi tamamladigi zaman Distributorden bir sonraki islemi almak icin cagrilir.                """		#reschedule worker		self.distributor._schedule(self)		def complete(self):                """		Distributor icindeki son islem tamamlandigi zaman Distributore islemlerin tamamlandigi bilgisini iletmek icin cagrilir.                """		self.distributor.complete(True)	def isactive(self):                """		Distributor'un hala aktif olup olmadigini kontrol etmek icin cagrilir.                 """		return self.distributor.isactive	class Distributor():        """	Bir islemin birden fazla asynchronous parca halinde concurrently calistirilmasi icin Workerlara islemleri schedule eden	mekanizma.        """	def __init__(self,processor,oncomplete=None,workers=1):                """                @type  processor: func                @param processor: Worker'larin islemleri gerceklestirmek icin cagirmalari gereken fonksiyon                @type  oncomplete: func                @param oncomplete: butun islemler tamamlandigi zaman cagrilacak fonksiyon                @type  workers: int                @param workers: yaratilacak Worker sayisi                """		#state		self.isactive=True		self.complete_on_no_data=False		#set processor		self.processor=processor		#initial dataset		self.dataset=[]				#set oncomplete callback		self.oncomplete=oncomplete		#create dispatcher		self.dispatcher=self._dispatcher()		#prepare dispatcher coroutine		self.dispatcher.next()		#create worker queue		self.worker_count=workers		self.workers=[]		for i in range(self.worker_count):			self.workers.append(Worker(self,i))			def run(self):                """		Distributoru calistir.                """		#if inactive, return		if self.isactive is False:			return		#notify dispatcher		self.dispatcher.send(None)	def adddata(self,data):                """		Distributorun islem listesine yeni islem/veriler ekler.		@type data: list                @param data: Distributorun islem listesine eklenecek islem/verilerin listesi                """		#add data		for item in data:			self.dataset.append(item)		#notify dispatcher		self.dispatcher.send(None)	def complete(self,abort=False):                """		Distributore sirada bekleyen islemler tamamlandiktan sonra ya da bu islemlerin tamamlanmasini beklemeden tanimli isi		tamamlamasi dikrektifini verir.                @type  abort: bool                @param abort: eger False ise Distributor sirada bekleyen islemleri tamamlar. eger True ise sirada bekleyen islemlerin			      tamamlanmasi beklenmeden Distributor uzerinde calistigi islem listesini tamamlanmis olarak gunceller.                """		#if 'abort now', complete now		if abort:			#reset state			self.complete_on_no_data=False			#complete			self._check_completed(True)		else:			#set flag to complete when all outstanding data is processed			self.complete_on_no_data=True			#check if complete now			self._check_completed()	def _check_completed(self,abort=False):                """		Distributorun uzerinde calistigi islemlerin tamamlanip tamamlanmamis oldugunu kontrol eder. Eger butun islemler		tamamlandiysa ya da kalan islemlerin iptali istendiyse, daha onceden islemler tamamlandigi zaman cagrilmasi 		belirtilen fonksiyon cagrilir.                @type  abort: bool                @param abort: eger False ise sirada bekleyen butun islemlerin tamamlanmis olup olmadigi kontrol edilir, eger True			      ise sirada bekleyen islemler iptal edilerek islem grubu tamamlanmis olarak kabul edilir..                """		#if this is not an 'abort now' request, look at the status		if abort is False:			#if the 'complete until no data' flag is not set, do not do anything			if self.complete_on_no_data is False:				return			#if there's still data to be processed, wait			if len(self.dataset)>0:				return			#if there's no data queued but workers still processing, wait for all workers to be done			if len(self.dataset)==0 and len(self.workers)<self.worker_count:				return		#if already completed, nothing to do		if self.isactive is False:			return		#deactivate		self.isactive=False		#make callback		if self.oncomplete is not None:			self.oncomplete()	def _schedule(self,worker):                """		Distributore bir Worker'in siradaki bir islem uzerinde calismak icin hazir oldugunu belirtir	                """		#put worker on the queue		self.workers.append(worker)		#notify dispatcher		try:				self.dispatcher.send(None)		except StopIteration as e:			pass		except Exception as e:			pass			#complete?		self._check_completed()	def _getdata(self):                """		Islem icin hazir bekleyen bir Workera uzerinde calismasi icin verilecek islem/verileri alir                @return: Worker'a verilecek islem/veriler                """		#check if there's data		if len(self.dataset)==0:			return None		#get data		data=self.dataset[0]		#remove from list		self.dataset=self.dataset[1:]		return data	def _dispatcher(self):                """		Distributorun Workerlara islemleri dagitmak icin kullandigi coroutine mekanizmasi                """		while True:			#wait for next worker to be available			signal=yield			#check status			if self.isactive is False:				continue			#dispatch each scheduled worker			for worker in self.workers:				#get data				data=self._getdata()				#if there's no data, go back to waiting				if data is None:					break				#take worker of the queue				self.workers.remove(worker)				#dispatch worker				worker.worker.send(data)				if __name__=="__main__":	#testing for Distriutor/Worker model	def process(data,worker):		print str(worker.id)+": "+repr(data)		worker.next()	def complete():		print "done"	d=Distributor(process,oncomplete=complete,workers=4)	count=1	for worker in d.workers:		worker.id=count		count=count+1	d.run()	d.adddata([10,12,40,94])	d.adddata(range(10))	reactor.callLater(5,d.adddata,[100,10000])		reactor.callLater(6,d.complete,False)	reactor.run()